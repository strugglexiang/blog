# 前言
本篇大幅参考[掘金老姚](https://juejin.im/post/5965943ff265da6c30653879)  

# 正则表达式位置匹配攻略
正则表达式是匹配模式，要么匹配字符，要么匹配位置，本篇是位置匹配攻略。

# 目录
- [什么是位置](#什么是位置)
- [如何匹配位置](#如何匹配位置)
  - [^和$](#^和$^和$)
  - [\b和\B](#\b和\B)
  - [(?=p)和(?!p)](#(?=p)和(?!p))
- [位置的理解](#位置的理解)
- [案例分析](#案例分析)
  - [不匹配任何字符的正则](#不匹配任何字符的正则)
  - [数字的千分位表示法](#数字的千分位表示法)
  - [验证密码问题](#验证密码问题)
    - [解法一](#解法一)
    - [解法二](#解法二)
- [总结](#总结)


# 什么是位置
位置是相邻字符之间的位置。如下图的箭头指向的地方： 
![位置](http://source.strugglexiang.xyz/1568172120.jpg)

# 如何匹配位置
正则表达式中有如下字符（锚字符）表示位置：  
> ^  多行匹配中匹配开头
>
> $  多行匹配中匹配结尾
>
> \b 单词边界
>
> \B 非单词边界
>
> (?=p) 正向先行断言
>
> (?!p) 负向先行断言

下面分别详细解释上述位置所代表的含义。

## ^和$
^(脱字符)：多行匹配中匹配开头  
$(美元符号)：多行匹配中匹配结尾

例1：
```js
console.log('hello'.replace(/^|$/g, '#'))
// => #hello#
```
没错，位置的可以替换的，上述示例中开头和结尾都替换成了`#`。

注意：   
1. 上述示例中使用到`g`修饰符，表示全局匹配，如不使用将只会匹配开头`^`。
2. 当位置替换时，正则表达式中应只出现表示位置锚字符，如果锚字符和普通字符同时使用，匹配（或替换）的将是普通字符。如：
```js
var regex  = /o\b/
console.log('dnoddfadfno ddd'.replace(regex, '#'))
// => 'dnoddfadfn# ddd'
```
可以看到，第二个`0`被替换成了`#`。也就是说，位置符的主要作用是**对要匹配的字符做某种条件限制**（这一点在自己写正则时比较关键）。


例2： 
```js
var str = 'I\nlove\njavaScript'
console.log(str.replace(/^|$/gm, '#'))
// => #I#\n#love#\n#javascript#
```
上述示例使用`m`修饰符，表示多行匹配


## \b和\B
\b：单词边界。具体就是`\w和\W`、`\w和^`、`\w和$`之间的位置。

例：
```js
var str = '[xian]yu.jpg'
str = str.replace(/\b/g, '#')
console.log(str)
// => [#xian#]#yu#.#jpg# 
```
解析：  
我们知道\w的[0-9a-zA-Z_]的简写，\W是[^0-9a-zA-Z_]的简写  
1. 第1个# \W与\w 即`[`与`x`之间的位置
2. 第2个# \w与\W 即`n`与`]`之间的位置
3. 第3个# \W与\w 即`]`与`y`之间的位置
4. 第4个# \w与\W 即`u`与`.`之间的位置
5. 第5个# \W与\w 即`.`与`j`之间的位置
6. 第6个# \w与\W 即`g`与`$`之间的位置

\B：非单词边界。它是`\b`的反义，即去掉字符串的所有的`\b`，其余位置都是`\B`。具体表示`\w和\w`、`\W和\W`、`\W和^`、`\W和$`之间的位置。
例：
```js
var str = '[xian]yu.jpg'
str = str.replace(/\B/g, '#')
console.log(str)
// => #[x#i#a#n]y#u.j#p#g 
```
> 快速记忆：单词之间的所有位置都的\B
> 
> xian => x#i#a#n

## (?=p)和(?!p)
(?=p)：其中p表示一个子模式，即**p前面的位置**。它的英文是`positive lookahead`，翻译成正向前行断言。
```js
var regex = /(?=l)/g
var str = 'hello'
console.log(str.replace(regex, '#'))
// => he#l#lo
```
可以看到，`l`前的位置被替换成了`#`


(?!p)：negative lookahead，负向先行断言，它是`(?=p)`的反义，即某个不是p的字符前面的位置。
```js
var regex = /(?!l)/g
var str = 'hello'
console.log(str.replace(regex, '#'))
// =>  #h#ell#o#
```

前面说过，位置除了可以替换外，它主要的作用是对某个要匹配的字符串或者子串做条件限制。  
例：
```js
var regex = /y(?=x)/
var str = 'y1yx'
console.log(str.replace(regex, '#'))
// y1#x
```
`/y(?=x)/`的在一些文献中一般都理解为**匹配y当且紧当y后面紧跟x时**。但是我们要将其做位置理解比较好，即：匹配y和x前面的位置。

先前我们说的正向先行断言和负向先行断言，es6中还支持正向后行断言和负向后行断言。 
> (?<=p) 正向后行断言(positive lookbehind)，匹配某个位置，该位置前面是p。
>
> (?<!p) 正向后行断言(positive lookbehind)，匹配某个位置，该位置不是p。


有关断言说了这么多，我自己本人都有点被饶糊涂了，以下是我个人的件记忆方式：
> (?=p) 匹配某个位置，该位置后面是p，对某个位置后面做条件限制。 没有`<`，是先行断言，没有`!`，正向，正向先行断言。
>
> (?!p) 匹配某个位置，该位置后面不是p，对某个位置后面做条件限制。没有`<`，是先行断言，有`!`，负向，负向先行断言。
> 
> (?<=p) 匹配某个位置，该位置前面是p，对某个位置前面做条件限制。有`<`，是后行断言，没有`!`，正向，正向后行断言。
>
> (?<!p) 匹配某个位置，该位置前面不是p，对某个位置前面做条件限制。有`<`，是后行断言，有`!`，负向，负向后行断言。


# 位置的理解
关于位置的理解，我们可以将其理解成空字符""。

例1：   
"hello" = "" + "h" + "" + "e" + "" + "l" + "" + "l" + "" + "0" + ""

例2：    
"hello" = "" + "" + "hello"

因此，位置是可以重叠的，`/^hello$/`也可以写成`/^^^hello$$$$/`
```js
console.log(/^hello$/.test('hello')) //true
console.log(/^^^hello$$$$/.test('hello'))//true
```

甚至可以写得更加复杂：
```js
console.log(/(?=he)^he(?=\w)llo\b\b$/.test('hello'))//true

console.log(/(?=he)^he(?=\w)ll\$$\B/.test('hell$'))//true
```

# 案例分析
## 不匹配任何字符的正则 
.^：匹配一个字符，该字符是后面是开头。

(?=x)y：某个位置后面紧跟x，却紧跟y

## 数字的千分位表示法
把`"12345678"`变成`12,345,678`

### 弄出最后一个逗号
```js
var regex = /(?=\d{3}$)/
console.log('12345678'.replace(regex, ','))
//12345,678
```
`$`符号不能写在括号外，即：/(?=\d{3})$/，位置重叠，这样匹配一个位置，该位置是结尾位置，并且该位置后紧跟3个数字，明显自相矛盾。

### 弄出多个逗号
从结束位置，每3个数字为一组，至少出现1次，因此使用量词`+`。
```js
var regex = /(?=(\d{3})+$)/g
console.log('12345678'.replace(regex, ','))
// 12,345,678
```
即从结尾开始，第n个连续3个数字前的位置替换成`,`

### 完善案例漏洞
```js
var regex = /(?=(\d{3})+$)/g
console.log('123456789'.replace(regex, ','))
// ,123,456,789
```
可以看到，需排除开头的位置，使用`(?!^)`
```js
var regex = /(?!^)(?=(\d{3})+$)/g
console.log('123456789'.replace(regex, ','))
// 123,456,789
```

### 支持其他形式
如果要将`"12345678 123456789"`替换成`"12,345,678 123,456,789"`，需要将^、$符号替换成`\b`
```js
var regex = /(?!\b)(?=(\d{3})+\b)/g
console.log('12345678 123456789'.replace(regex, ','))
// 12,345,678 123,456,789
```
即从单词边界开始，以3个数字为一组的位置添加`,`，但是这个位置不是能是单词边界。

其中，`(?!\b)`就是`\B`
```js
var regex = /\B(?=(\d{3})+\b)/g
console.log('12345678 123456789'.replace(regex, ','))
// => 12,345,678 123,456,789
```

## 验证密码问题
密码长度为6-12位，由数字、小写字母、大写字母组成，要求必须包含两种字符。

1、数字、小写字母、大写字母组成的6-12位密码，写成`/[0-9a-zA-z]{6-12}/`




### 解法一
### 解法二
# 总结